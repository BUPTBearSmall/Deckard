This is a pre-release package of Deckard -- a tree-based, scalable,
and accurate code clone detection tool. 

****************************
* LICENSE
****************************
3-clause BSD licence

****************************
* Installation
****************************
cd src/main
./build.sh

For convenience, add "src/main" into $PATH.

NOTE: Deckard's built-in parser for Java cannot handle Java 1.5 or later
features, which means when Deckard processes a Java 1.5 file, it is very likely
there will be no vector generated.


****************************
* Usage
****************************

1. For clone detection (suppose the source code of your application is
in /path/to/app/src):

 - Identify the location of your source code, say /path/to/app/src.

 - Create a "config" file in /path/to/app/.
   Refer to the sample "config" in samples/.
   Make sure all paths are valid.

 - (Optional) create other three directories in /path/to/app/ for storing outputs
   (see samples/)

 - Vector generation: from where "config" is, run
   "/path/to/scripts/clonedetect/vdbgen"

 - Vector clustering (i.e., clone detection): from where "config" is, run
   "/path/to/scripts/clonedetect/vertical-group-batch"

2. Vector generation for parts of a file:

 - Identify the source file name, say /path/to/src/filename.java

 - Run "src/main/jvecgen [options] /path/to/src/filename.java --start-line-number <s> --end-line-number <e>"
   Run "jvecgen -h" for more options.
   Run different vecgen for files in different languages.

This command will generate a vector representing the code between Line <s> and
<e> in the source file, and store the vector in filename.java.vec by default.


************************************************************
* How to programmably use the vectors and the clone reports?
************************************************************

1. How to get the subtrees representing each clone?

Each clone in the reports has a TBID and a TEID, in addition to the file name,
and line numbers. The TBID and TEID uniquely identify the IDs of the first
token and the last token in the clone from the original file (possibly
containing parsing errors). The following are the main steps; Please refer to
"src/main/vgen/treeTra/token-tree-map.h" for more implementation details.

 - Given a line from the clone report file, parse it to get file name, line
   numbers, TBID, and TEID, etc.  C.f. the function:
   bool parse(char * line, regex_t patterns[], int dim=ENUM_CLONE_THE_END)

 - Call "yyparse()" on the source file again to get the root of the whole parse tree

 - Call the following function to get the smallest tree that contains all
   tokens between TBID and TEID:
   Tree* tokenRange2Tree2(std::pair<long, long> tokenrange, ParseTree* pt)

2. How to get the vector for a line or a sequence of lines from a file?

Option 1: See above "Vector generation for parts of a file."

Option 2: Given the parse tree for a file (through yyparse() again) and the
starting/ending line number,

  - (Only if not done before,) Call Deckard's vector generator on the parse
    tree.  C.f., TraGenMain::run(int startln, int endln) and
    VecGenerator::traverse(Tree* root, Tree* init).
    

  - Call the following function (c.f. include/ptree.h, src/main/ptree.cc) to
    return the smallest tree enclosing all elements from these lines:
    Tree* ParseTree::line2Tree(int startln, int endln)

  - Then retrieve the vector (the actual vector generation is done separately):
    TreeVector* tv = TreeAccessor::get_node_vector(tree_node_pointer)

